/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\config\AdminSeeder.java ===== */
package Springboot.config;

import Springboot.model.UserModel;
import Springboot.repository.UserRepository;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@Component
public class AdminSeeder implements ApplicationRunner {

    private final UserRepository userRepository;

    public AdminSeeder(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Value("${admin.seed.enabled:false}")
    private boolean seedEnabled;

    @Value("${admin.seed.email:}")
    private String adminEmail;

    @Value("${admin.seed.password:}")
    private String adminPassword;

    @Value("${admin.seed.username:Admin}")
    private String adminUsername;

    @Value("${admin.seed.companyName:}")
    private String companyName;

    @Value("${admin.seed.companyDescription:}")
    private String companyDescription;

    @Value("${admin.seed.companyWebsite:}")
    private String companyWebsite;

    @Value("${admin.seed.companySize:}")
    private String companySize;

    @Value("${admin.seed.industry:}")
    private String industry;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        if (!seedEnabled) return;
        if (adminEmail == null || adminEmail.isBlank() || adminPassword == null || adminPassword.isBlank()) {
            return; // misconfigured; skip silently
        }

        UserModel admin = userRepository.findByEmail(adminEmail).orElse(null);
        if (admin == null) {
            BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
            admin = new UserModel();
            admin.setEmail(adminEmail);
            admin.setUsername(adminUsername);
            admin.setRole("ADMIN");
            admin.setPassword(encoder.encode(adminPassword));
            // Optional company fields
            admin.setCompanyName(companyName);
            admin.setCompanyDescription(companyDescription);
            admin.setCompanyWebsite(companyWebsite);
            admin.setCompanySize(companySize);
            admin.setIndustry(industry);
            userRepository.save(admin);
        } else {
            boolean changed = false;
            if (admin.getRole() == null || !"ADMIN".equals(admin.getRole())) {
                admin.setRole("ADMIN");
                changed = true;
            }
            if (admin.getUsername() == null || admin.getUsername().isBlank()) {
                admin.setUsername(adminUsername);
                changed = true;
            }
            // Do not overwrite existing password or company details if already present
            if (changed) {
                userRepository.save(admin);
            }
        }
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\config\GridFSConfig.java ===== */
package Springboot.config;

import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoDatabase;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.MongoDatabaseFactory;
import org.springframework.data.mongodb.core.convert.MappingMongoConverter;
import org.springframework.data.mongodb.gridfs.GridFsTemplate;

@Configuration
public class GridFSConfig {

    @Autowired
    private MongoDatabaseFactory mongoDatabaseFactory;

    @Autowired
    private MappingMongoConverter mappingMongoConverter;

    @Bean
    public GridFsTemplate gridFsTemplate() {
        return new GridFsTemplate(mongoDatabaseFactory, mappingMongoConverter);
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\config\SecurityConfig.java ===== */
package Springboot.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import Springboot.security.JwtAuthenticationFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpMethod;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import java.util.List;

@Configuration
public class SecurityConfig {

    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> {})
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        // Always allow preflight
                        .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                        .requestMatchers("/auth/**").permitAll()
                        // Public reads for jobs
                        .requestMatchers(HttpMethod.GET, "/jobs", "/jobs/search", "/jobs/*", "/jobs/**").permitAll()
                        // Admin writes for jobs
                        .requestMatchers(HttpMethod.POST, "/jobs", "/jobs/**").hasRole("ADMIN")
                        .requestMatchers(HttpMethod.PUT, "/jobs/**").hasRole("ADMIN")
                        .requestMatchers(HttpMethod.PATCH, "/jobs/**").hasRole("ADMIN")
                        .requestMatchers(HttpMethod.DELETE, "/jobs/**").hasRole("ADMIN")
                        .requestMatchers("/applications/me").hasRole("JOBSEEKER")
                        .requestMatchers("/applications/**").authenticated()
                        .anyRequest().authenticated()
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**") // allow all endpoints
                        .allowedOrigins("http://localhost:5173") // frontend
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH")
                        .allowedHeaders("*")
                        .allowCredentials(true);
            }
        };
    }

    // Provide explicit CORS configuration for Spring Security to use
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(List.of("http://localhost:5173"));
        config.setAllowedMethods(List.of("GET","POST","PUT","DELETE","PATCH","OPTIONS"));
        config.setAllowedHeaders(List.of("*"));
        config.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\controller\JobApplicationController.java ===== */
package Springboot.controller;

import Springboot.model.JobApplicationModel;
import Springboot.model.JobModel;
import Springboot.model.UserModel;
import Springboot.repository.UserRepository;
import Springboot.service.JobApplicationService;
import Springboot.service.JobService;
import org.springframework.http.ResponseEntity;
import org.springframework.http.MediaType;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/applications")
@CrossOrigin(origins = "http://localhost:5173")
public class JobApplicationController {

    private final JobApplicationService jobApplicationService;
    private final JobService jobService;
    private final UserRepository userRepository;

    public JobApplicationController(JobApplicationService jobApplicationService, JobService jobService, UserRepository userRepository) {
        this.jobApplicationService = jobApplicationService;
        this.jobService = jobService;
        this.userRepository = userRepository;
    }

    // Jobseeker applies to a job (multipart - with resume upload)
    @PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<?> apply(
            @RequestParam String jobId,
            @RequestPart(required = false) MultipartFile resume,
            @RequestParam(required = false) String coverLetter
    ) {
        String jobSeekerId = getCurrentUserId();
        try {
            JobApplicationModel application = jobApplicationService.applyForJob(jobId, jobSeekerId, resume, coverLetter);
            return ResponseEntity.ok(application);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    // Jobseeker applies to a job (JSON - without resume upload in this request)
    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<?> applyJson(@RequestBody ApplyRequest request) {
        String jobSeekerId = getCurrentUserId();
        try {
            JobApplicationModel application = jobApplicationService.applyForJob(request.getJobId(), jobSeekerId, null, request.getCoverLetter());
            return ResponseEntity.ok(application);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    // Jobseeker views own applications
    @GetMapping("/me")
    public ResponseEntity<List<JobApplicationModel>> myApplications() {
        String jobSeekerId = getCurrentUserId();
        return ResponseEntity.ok(jobApplicationService.getApplicationsByJobSeeker(jobSeekerId));
    }

    // Admin views applications for a job they posted
    @GetMapping("/job/{jobId}")
    public ResponseEntity<?> applicationsForJob(@PathVariable String jobId) {
        String adminId = getCurrentUserId();
        Optional<JobModel> job = jobService.getJobById(jobId);
        if (job.isEmpty() || !job.get().getPostedBy().equals(adminId)) {
            return ResponseEntity.status(403).body("Forbidden: Not your job posting");
        }
        return ResponseEntity.ok(jobApplicationService.getApplicationsForJob(jobId));
    }

    // Admin updates application status
    @PatchMapping("/{applicationId}/status")
    public ResponseEntity<?> updateStatus(@PathVariable String applicationId, @RequestParam String status) {
        String adminId = getCurrentUserId();
        try {
            JobApplicationModel updated = jobApplicationService.updateApplicationStatus(applicationId, status, adminId);
            return ResponseEntity.ok(updated);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    // Get application by id (must be owner or admin of job)
    @GetMapping("/{applicationId}")
    public ResponseEntity<?> getApplication(@PathVariable String applicationId) {
        Optional<JobApplicationModel> app = jobApplicationService.getApplicationById(applicationId);
        if (app.isEmpty()) return ResponseEntity.notFound().build();
        String requesterId = getCurrentUserId();
        JobApplicationModel application = app.get();
        // if requester is jobseeker owner
        if (application.getJobSeekerId().equals(requesterId)) return ResponseEntity.ok(application);
        // if requester is admin who owns the job
        Optional<JobModel> job = jobService.getJobById(application.getJobId());
        if (job.isPresent() && job.get().getPostedBy().equals(requesterId)) return ResponseEntity.ok(application);
        return ResponseEntity.status(403).body("Forbidden");
    }

    // Jobseeker withdraws application
    @DeleteMapping("/{applicationId}")
    public ResponseEntity<?> withdraw(@PathVariable String applicationId) {
        String jobSeekerId = getCurrentUserId();
        try {
            jobApplicationService.withdrawApplication(applicationId, jobSeekerId);
            return ResponseEntity.ok().build();
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    private String getCurrentUserId() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth != null ? (String) auth.getPrincipal() : null;
        if (email == null) throw new RuntimeException("Unauthorized");
        Optional<UserModel> user = userRepository.findByEmail(email);
        if (user.isEmpty()) throw new RuntimeException("User not found");
        return user.get().getId();
    }

    // Simple DTO for JSON application request
    public static class ApplyRequest {
        private String jobId;
        private String coverLetter;

        public String getJobId() {
            return jobId;
        }

        public void setJobId(String jobId) {
            this.jobId = jobId;
        }

        public String getCoverLetter() {
            return coverLetter;
        }

        public void setCoverLetter(String coverLetter) {
            this.coverLetter = coverLetter;
        }
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\controller\JobController.java ===== */
package Springboot.controller;

import Springboot.model.JobModel;
import Springboot.model.UserModel;
import Springboot.repository.UserRepository;
import Springboot.service.JobService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/jobs")
@CrossOrigin(origins = "http://localhost:5173")
public class JobController {

    private final JobService jobService;
    private final UserRepository userRepository;
    private static final Logger log = LoggerFactory.getLogger(JobController.class);

    public JobController(JobService jobService, UserRepository userRepository) {
        this.jobService = jobService;
        this.userRepository = userRepository;
    }

    // Public endpoints
    @GetMapping
    public ResponseEntity<List<JobModel>> getAllActiveJobs() {
        return ResponseEntity.ok(jobService.getAllActiveJobs());
    }

    @GetMapping("/{id}")
    public ResponseEntity<?> getJobById(@PathVariable String id) {
        Optional<JobModel> job = jobService.getJobById(id);
        return job.<ResponseEntity<?>>map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

    @GetMapping("/search")
    public ResponseEntity<List<JobModel>> searchJobs(@RequestParam(required = false) String keyword,
                                                     @RequestParam(required = false) String location,
                                                     @RequestParam(required = false) String jobType,
                                                     @RequestParam(required = false) String experienceLevel) {
        return ResponseEntity.ok(jobService.searchJobs(keyword, location, jobType, experienceLevel));
    }

    // Admin endpoints
    @GetMapping("/mine")
    public ResponseEntity<?> myJobs() {
        String adminId = getCurrentUserId();
        try {
            return ResponseEntity.ok(jobService.getJobsByAdmin(adminId));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping
    public ResponseEntity<?> createJob(@RequestBody JobModel job) {
        try {
            String adminId = getCurrentUserId();
            log.info("Create job request by adminId={} title={} location={} jobType={}", adminId, job.getTitle(), job.getLocation(), job.getJobType());
            JobModel created = jobService.createJob(job, adminId);
            log.info("Job created with id={} by adminId={}", created.getId(), adminId);
            return ResponseEntity.ok(created);
        } catch (Exception e) {
            log.warn("Create job failed: {}", e.getMessage());
            if ("Unauthorized".equals(e.getMessage()) || "User not found".equals(e.getMessage())) {
                return ResponseEntity.status(401).body(e.getMessage());
            }
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> updateJob(@PathVariable String id, @RequestBody JobModel job) {
        try {
            String adminId = getCurrentUserId();
            JobModel updated = jobService.updateJob(id, job, adminId);
            log.info("Job updated id={} by adminId={}", id, adminId);
            return ResponseEntity.ok(updated);
        } catch (Exception e) {
            log.warn("Update job failed id={}: {}", id, e.getMessage());
            if ("Unauthorized".equals(e.getMessage()) || "User not found".equals(e.getMessage())) {
                return ResponseEntity.status(401).body(e.getMessage());
            }
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteJob(@PathVariable String id) {
        try {
            String adminId = getCurrentUserId();
            jobService.deleteJob(id, adminId);
            log.info("Job deleted id={} by adminId={}", id, adminId);
            return ResponseEntity.ok().build();
        } catch (Exception e) {
            log.warn("Delete job failed id={}: {}", id, e.getMessage());
            if ("Unauthorized".equals(e.getMessage()) || "User not found".equals(e.getMessage())) {
                return ResponseEntity.status(401).body(e.getMessage());
            }
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PatchMapping("/{id}/deactivate")
    public ResponseEntity<?> deactivateJob(@PathVariable String id) {
        try {
            String adminId = getCurrentUserId();
            jobService.deactivateJob(id, adminId);
            return ResponseEntity.ok().build();
        } catch (Exception e) {
            if ("Unauthorized".equals(e.getMessage()) || "User not found".equals(e.getMessage())) {
                return ResponseEntity.status(401).body(e.getMessage());
            }
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    private String getCurrentUserId() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth != null ? (String) auth.getPrincipal() : null;
        if (email == null) throw new RuntimeException("Unauthorized");
        Optional<UserModel> user = userRepository.findByEmail(email);
        if (user.isEmpty()) throw new RuntimeException("User not found");
        log.debug("Resolved current user email={} to id={}", email, user.get().getId());
        return user.get().getId();
    }

}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\controller\ProfileController.java ===== */
package Springboot.controller;

import Springboot.model.UserModel;
import Springboot.repository.UserRepository;
import Springboot.service.FileStorageService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.Optional;

@RestController
@RequestMapping("/me")
@CrossOrigin(origins = "http://localhost:5173")
public class ProfileController {

    private final UserRepository userRepository;
    private final FileStorageService fileStorageService;

    public ProfileController(UserRepository userRepository, FileStorageService fileStorageService) {
        this.userRepository = userRepository;
        this.fileStorageService = fileStorageService;
    }

    @GetMapping
    public ResponseEntity<?> getMe() {
        UserModel me = requireCurrentUser();
        me.setPassword(null);
        return ResponseEntity.ok(me);
    }

    @PutMapping
    public ResponseEntity<?> updateMe(@RequestBody UserModel incoming) {
        UserModel me = requireCurrentUser();
        // update allowed fields
        me.setFirstName(incoming.getFirstName());
        me.setLastName(incoming.getLastName());
        me.setPhone(incoming.getPhone());
        me.setProfileSummary(incoming.getProfileSummary());
        me.setSkills(incoming.getSkills());
        me.setExperience(incoming.getExperience());
        me.setEducation(incoming.getEducation());
        me.setLocation(incoming.getLocation());
        // admin/company fields (if role is ADMIN)
        if ("ADMIN".equals(me.getRole())) {
            me.setCompanyName(incoming.getCompanyName());
            me.setCompanyDescription(incoming.getCompanyDescription());
            me.setCompanyWebsite(incoming.getCompanyWebsite());
            me.setCompanySize(incoming.getCompanySize());
            me.setIndustry(incoming.getIndustry());
        }
        userRepository.save(me);
        me.setPassword(null);
        return ResponseEntity.ok(me);
    }

    @PostMapping("/resume")
    public ResponseEntity<?> uploadResume(@RequestPart("file") MultipartFile resume) {
        try {
            UserModel me = requireCurrentUser();
            String fileId = fileStorageService.storeFile(resume, me.getId());
            me.setResumeFileId(fileId);
            me.setResumeFileName(resume.getOriginalFilename());
            userRepository.save(me);
            me.setPassword(null);
            return ResponseEntity.ok(me);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    private UserModel requireCurrentUser() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String email = auth != null ? (String) auth.getPrincipal() : null;
        if (email == null) throw new RuntimeException("Unauthorized");
        Optional<UserModel> user = userRepository.findByEmail(email);
        if (user.isEmpty()) throw new RuntimeException("User not found");
        return user.get();
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\controller\UserController.java ===== */
package Springboot.controller;

import Springboot.model.UserModel;
import Springboot.service.UserService;
import Springboot.security.JwtUtil;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/auth")
@CrossOrigin(origins = "http://localhost:5173") // React dev server
public class UserController {

    private final UserService userService;
    private final JwtUtil jwtUtil;
    public UserController(UserService userService, JwtUtil jwtUtil) {
        this.userService = userService;
        this.jwtUtil = jwtUtil;
    }

    @PostMapping("/signup")
    public ResponseEntity<?> signup(@RequestBody UserModel user) {
        try {
            UserModel savedUser = userService.signup(user);
            savedUser.setPassword(null); // hide password in response
            return ResponseEntity.ok(savedUser);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody UserModel user) {
        try {
            UserModel loggedUser = userService.login(user.getEmail(), user.getPassword());
            loggedUser.setPassword(null);

            String token = jwtUtil.generateToken(loggedUser.getEmail());
            return ResponseEntity.ok(new AuthResponse(loggedUser, token));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    public static class AuthResponse {
        public UserModel user;
        public String token;
        public AuthResponse(UserModel user, String token) {
            this.user = user;
            this.token = token;
        }
    }

}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\model\JobApplicationModel.java ===== */
package Springboot.model;

import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import jakarta.validation.constraints.NotBlank;
import java.time.LocalDateTime;

@Data
@Document("job_applications")
public class JobApplicationModel {
    @Id
    private String id;

    @NotBlank(message = "Job ID is required")
    private String jobId;

    @NotBlank(message = "Job seeker ID is required")
    private String jobSeekerId;

    private String resumeFileId; // GridFS file ID
    private String resumeFileName;
    private String resumeText; // Parsed resume text

    private String coverLetter;

    private LocalDateTime appliedAt;

    // AI Analysis Results
    private Integer skillScore; // Score from 0-100 based on LLM analysis
    private String skillAnalysis; // Detailed analysis from LLM
    private boolean passedInitialScreening; // Based on skill score threshold

    // Application Status
    private String status; // PENDING, UNDER_REVIEW, SHORTLISTED, REJECTED, HIRED

    // Additional fields for tracking
    private String jobTitle;
    private String companyName;
    private String jobSeekerName;
    private String jobSeekerEmail;

    public JobApplicationModel() {
        this.appliedAt = LocalDateTime.now();
        this.status = "PENDING";
        this.passedInitialScreening = false;
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\model\JobModel.java ===== */
package Springboot.model;

import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Min;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Document("jobs")
public class JobModel {
    @Id
    private String id;

    @NotBlank(message = "Job title is required")
    private String title;

    @NotBlank(message = "Job description is required")
    private String description;

    @NotBlank(message = "Company name is required")
    private String companyName;

    @NotBlank(message = "Location is required")
    private String location;

    @NotBlank(message = "Job type is required")
    private String jobType; // FULL_TIME, PART_TIME, CONTRACT, INTERNSHIP

    @NotBlank(message = "Experience level is required")
    private String experienceLevel; // ENTRY, MID, SENIOR, EXECUTIVE

    @NotNull(message = "Salary range is required")
    @Min(value = 0, message = "Minimum salary must be positive")
    private Double salaryMin;

    @NotNull(message = "Salary range is required")
    @Min(value = 0, message = "Maximum salary must be positive")
    private Double salaryMax;

    private String salaryCurrency; // USD, INR, etc.

    @NotNull(message = "Required skills are required")
    private List<String> requiredSkills;

    private List<String> preferredSkills;

    @NotBlank(message = "Requirements are required")
    private String requirements;

    private String benefits;

    @NotBlank(message = "Posted by admin ID is required")
    private String postedBy; // Admin user ID

    private LocalDateTime postedAt;
    private LocalDateTime updatedAt;
    private LocalDateTime applicationDeadline;

    @NotNull(message = "Skill score threshold is required")
    @Min(value = 0, message = "Skill score threshold must be between 0 and 100")
    private Integer skillScoreThreshold; // Minimum score required to pass initial screening

    private boolean isActive;
    private int applicationCount;

    // Company specific features
    private String companyLogo;
    private String companyWebsite;
    private String companyDescription;
    private String companySize;
    private String industry;

    public JobModel() {
        this.postedAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        this.isActive = true;
        this.applicationCount = 0;
        this.salaryCurrency = "USD";
        this.skillScoreThreshold = 60;
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\model\UserModel.java ===== */
package Springboot.model;

import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.index.Indexed;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Document("users")
public class UserModel {
    @Id
    private String id;

    @NotBlank(message = "Username is required")
    private String username;

    @Email(message = "Email should be valid")
    @NotBlank(message = "Email is required")
    @Indexed(unique = true)
    private String email;

    @NotBlank(message = "Password is required")
    private String password;

    @NotBlank(message = "Role is required")
    private String role; // ADMIN, JOBSEEKER

    // Common fields
    private String firstName;
    private String lastName;
    private String phone;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // JobSeeker specific fields
    private String profileSummary;
    private List<String> skills;
    private String experience; // e.g., "2-3 years", "5+ years"
    private String education;
    private String location;
    private String resumeFileId; // GridFS file ID
    private String resumeFileName;

    // Admin/Company specific fields
    private String companyName;
    private String companyDescription;
    private String companyWebsite;
    private String companySize;
    private String industry;

    public UserModel() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\repository\JobApplicationRepository.java ===== */
package Springboot.repository;

import Springboot.model.JobApplicationModel;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.data.mongodb.repository.Query;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface JobApplicationRepository extends MongoRepository<JobApplicationModel, String> {
    
    List<JobApplicationModel> findByJobSeekerId(String jobSeekerId);
    
    List<JobApplicationModel> findByJobId(String jobId);
    
    Optional<JobApplicationModel> findByJobIdAndJobSeekerId(String jobId, String jobSeekerId);
    
    @Query("{'status': ?0}")
    List<JobApplicationModel> findByStatus(String status);
    
    @Query("{'jobId': ?0, 'passedInitialScreening': true}")
    List<JobApplicationModel> findByJobIdAndPassedInitialScreeningTrue(String jobId);
    
    @Query("{'jobId': ?0, 'skillScore': {$gte: ?1}}")
    List<JobApplicationModel> findByJobIdAndSkillScoreGreaterThanEqual(String jobId, Integer minScore);
    
    long countByJobId(String jobId);
    
    long countByJobIdAndPassedInitialScreeningTrue(String jobId);
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\repository\JobRepository.java ===== */
package Springboot.repository;

import Springboot.model.JobModel;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.data.mongodb.repository.Query;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface JobRepository extends MongoRepository<JobModel, String> {
    
    List<JobModel> findByIsActiveTrue();
    
    List<JobModel> findByPostedBy(String postedBy);
    
    @Query("{'title': {$regex: ?0, $options: 'i'}}")
    List<JobModel> findByTitleContainingIgnoreCase(String title);
    
    @Query("{'location': {$regex: ?0, $options: 'i'}}")
    List<JobModel> findByLocationContainingIgnoreCase(String location);
    
    @Query("{'requiredSkills': {$in: ?0}}")
    List<JobModel> findByRequiredSkillsIn(List<String> skills);
    
    @Query("{'jobType': ?0, 'isActive': true}")
    List<JobModel> findByJobTypeAndIsActiveTrue(String jobType);
    
    @Query("{'experienceLevel': ?0, 'isActive': true}")
    List<JobModel> findByExperienceLevelAndIsActiveTrue(String experienceLevel);
    
    @Query("{'companyName': {$regex: ?0, $options: 'i'}, 'isActive': true}")
    List<JobModel> findByCompanyNameContainingIgnoreCaseAndIsActiveTrue(String companyName);
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\repository\UserRepository.java ===== */
package Springboot.repository;

import Springboot.model.UserModel;
import org.springframework.data.mongodb.repository.MongoRepository;

import java.util.Optional;

public interface UserRepository extends MongoRepository<UserModel, String>
{
    Optional<UserModel> findByEmail(String email);
    boolean existsByEmail(String email);
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\security\JwtAuthenticationFilter.java ===== */
package Springboot.security;

import Springboot.model.UserModel;
import Springboot.repository.UserRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;
import java.util.Optional;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final UserRepository userRepository;

    public JwtAuthenticationFilter(JwtUtil jwtUtil, UserRepository userRepository) {
        this.jwtUtil = jwtUtil;
        this.userRepository = userRepository;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String authHeader = request.getHeader("Authorization");

        if (StringUtils.hasText(authHeader) && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            try {
                String email = jwtUtil.extractEmail(token);
                Optional<UserModel> userOpt = userRepository.findByEmail(email);
                if (userOpt.isPresent()) {
                    UserModel user = userOpt.get();
                    String role = user.getRole() != null ? user.getRole() : "JOBSEEKER";
                    SimpleGrantedAuthority authority = new SimpleGrantedAuthority("ROLE_" + role);
                    Authentication authentication = new UsernamePasswordAuthenticationToken(
                            email,
                            null,
                            Collections.singletonList(authority)
                    );
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            } catch (Exception ex) {
                // Invalid token - clear context, continue chain (endpoint may still be permitted)
                SecurityContextHolder.clearContext();
            }
        }

        filterChain.doFilter(request, response);
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\security\JwtUtil.java ===== */
package Springboot.security;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Base64;
import java.util.Date;
import java.nio.charset.StandardCharsets;
import java.security.Key;

@Component
public class JwtUtil {
    @Value("${security.jwt.secret:change-me-super-secret-key-please}")
    private String secret;

    public String generateToken(String email) {
        return Jwts.builder()
                .setSubject(email)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10))
                .signWith(getKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public String extractEmail(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getKey())
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }

    private Key getKey() {
        // Ensure key is 256-bit for HS256
        byte[] keyBytes = Base64.getEncoder().encode(secret.getBytes(StandardCharsets.UTF_8));
        return Keys.hmacShaKeyFor(keyBytes);
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\service\FileStorageService.java ===== */
package Springboot.service;

import com.mongodb.client.gridfs.model.GridFSFile;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.gridfs.GridFsResource;
import org.springframework.data.mongodb.gridfs.GridFsTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;

@Service
public class FileStorageService {

    @Autowired
    private GridFsTemplate gridFsTemplate;

    public String storeFile(MultipartFile file, String userId) throws IOException {
        String filename = userId + "_" + System.currentTimeMillis() + "_" + file.getOriginalFilename();
        
        return gridFsTemplate.store(
            file.getInputStream(),
            filename,
            file.getContentType()
        ).toString();
    }

    public GridFsResource getFile(String fileId) {
        GridFSFile gridFSFile = gridFsTemplate.findOne(
            new Query(Criteria.where("_id").is(fileId))
        );
        
        if (gridFSFile != null) {
            return gridFsTemplate.getResource(gridFSFile);
        }
        
        return null;
    }

    public InputStream getFileInputStream(String fileId) throws IOException {
        GridFsResource resource = getFile(fileId);
        return resource != null ? resource.getInputStream() : null;
    }

    public void deleteFile(String fileId) {
        gridFsTemplate.delete(new Query(Criteria.where("_id").is(fileId)));
    }

    public boolean fileExists(String fileId) {
        GridFSFile gridFSFile = gridFsTemplate.findOne(
            new Query(Criteria.where("_id").is(fileId))
        );
        return gridFSFile != null;
    }

    public String getFileName(String fileId) {
        GridFSFile gridFSFile = gridFsTemplate.findOne(
            new Query(Criteria.where("_id").is(fileId))
        );
        return gridFSFile != null ? gridFSFile.getFilename() : null;
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\service\JobApplicationService.java ===== */
package Springboot.service;

import Springboot.model.JobApplicationModel;
import Springboot.model.JobModel;
import Springboot.model.UserModel;
import Springboot.repository.JobApplicationRepository;
import Springboot.repository.JobRepository;
import Springboot.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;
import java.util.List;
import java.util.Optional;

@Service
public class JobApplicationService {

    @Autowired
    private JobApplicationRepository jobApplicationRepository;

    @Autowired
    private JobRepository jobRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private FileStorageService fileStorageService;

    @Autowired
    private ResumeParsingService resumeParsingService;

    @Autowired
    private LLMAnalysisService llmAnalysisService;

    @Autowired
    private JobService jobService;

    public JobApplicationModel applyForJob(String jobId, String jobSeekerId, 
                                         MultipartFile resumeFile, String coverLetter) {
        try {
            // Validate job exists and is active
            Optional<JobModel> job = jobRepository.findById(jobId);
            if (job.isEmpty() || !job.get().isActive()) {
                throw new RuntimeException("Job not found or no longer active");
            }

            // Validate job seeker
            Optional<UserModel> jobSeeker = userRepository.findById(jobSeekerId);
            if (jobSeeker.isEmpty() || !"JOBSEEKER".equals(jobSeeker.get().getRole())) {
                throw new RuntimeException("Invalid job seeker");
            }

            // Check if already applied
            Optional<JobApplicationModel> existingApplication = 
                jobApplicationRepository.findByJobIdAndJobSeekerId(jobId, jobSeekerId);
            if (existingApplication.isPresent()) {
                throw new RuntimeException("You have already applied for this job");
            }

            JobModel jobModel = job.get();
            UserModel jobSeekerModel = jobSeeker.get();

            // Create application
            JobApplicationModel application = new JobApplicationModel();
            application.setJobId(jobId);
            application.setJobSeekerId(jobSeekerId);
            application.setCoverLetter(coverLetter);
            application.setJobTitle(jobModel.getTitle());
            application.setCompanyName(jobModel.getCompanyName());
            application.setJobSeekerName(jobSeekerModel.getFirstName() + " " + jobSeekerModel.getLastName());
            application.setJobSeekerEmail(jobSeekerModel.getEmail());

            // Handle resume upload and parsing
            if (resumeFile != null && !resumeFile.isEmpty()) {
                // Validate file type
                if (!resumeParsingService.isSupportedFileType(resumeFile.getContentType())) {
                    throw new RuntimeException("Unsupported file type. Please upload PDF, DOC, DOCX, or TXT files.");
                }

                // Store file in GridFS
                String fileId = fileStorageService.storeFile(resumeFile, jobSeekerId);
                application.setResumeFileId(fileId);
                application.setResumeFileName(resumeFile.getOriginalFilename());

                // Parse resume text
                String resumeText = resumeParsingService.parseResume(resumeFile);
                application.setResumeText(resumeText);

                // Analyze resume against job requirements using LLM
                LLMAnalysisService.SkillAnalysisResult analysisResult = 
                    llmAnalysisService.analyzeResumeAgainstJob(
                        resumeText, 
                        jobModel.getDescription(), 
                        jobModel.getRequiredSkills()
                    );

                application.setSkillScore(analysisResult.getScore());
                application.setSkillAnalysis(analysisResult.getFullAnalysis());

                // Check if passes initial screening
                boolean passedScreening = analysisResult.getScore() >= jobModel.getSkillScoreThreshold();
                application.setPassedInitialScreening(passedScreening);

                if (passedScreening) {
                    application.setStatus("UNDER_REVIEW");
                } else {
                    application.setStatus("REJECTED");
                }
            } else {
                // Use existing resume from user profile if available
                if (jobSeekerModel.getResumeFileId() != null) {
                    application.setResumeFileId(jobSeekerModel.getResumeFileId());
                    application.setResumeFileName(jobSeekerModel.getResumeFileName());

                    // Parse existing resume
                    try (InputStream resumeStream = fileStorageService.getFileInputStream(jobSeekerModel.getResumeFileId())) {
                        if (resumeStream != null) {
                            String resumeText = resumeParsingService.parseResume(resumeStream);
                            application.setResumeText(resumeText);

                            // Analyze resume
                            LLMAnalysisService.SkillAnalysisResult analysisResult = 
                                llmAnalysisService.analyzeResumeAgainstJob(
                                    resumeText, 
                                    jobModel.getDescription(), 
                                    jobModel.getRequiredSkills()
                                );

                            application.setSkillScore(analysisResult.getScore());
                            application.setSkillAnalysis(analysisResult.getFullAnalysis());

                            boolean passedScreening = analysisResult.getScore() >= jobModel.getSkillScoreThreshold();
                            application.setPassedInitialScreening(passedScreening);

                            if (passedScreening) {
                                application.setStatus("UNDER_REVIEW");
                            } else {
                                application.setStatus("REJECTED");
                            }
                        }
                    }
                } else {
                    throw new RuntimeException("Please upload a resume or update your profile with a resume");
                }
            }

            // Save application
            JobApplicationModel savedApplication = jobApplicationRepository.save(application);

            // Increment job application count
            jobService.incrementApplicationCount(jobId);

            return savedApplication;

        } catch (Exception e) {
            throw new RuntimeException("Failed to submit application: " + e.getMessage(), e);
        }
    }

    public List<JobApplicationModel> getApplicationsByJobSeeker(String jobSeekerId) {
        return jobApplicationRepository.findByJobSeekerId(jobSeekerId);
    }

    public List<JobApplicationModel> getApplicationsForJob(String jobId) {
        return jobApplicationRepository.findByJobId(jobId);
    }

    public List<JobApplicationModel> getQualifiedApplicationsForJob(String jobId) {
        return jobApplicationRepository.findByJobIdAndPassedInitialScreeningTrue(jobId);
    }

    public Optional<JobApplicationModel> getApplicationById(String applicationId) {
        return jobApplicationRepository.findById(applicationId);
    }

    public JobApplicationModel updateApplicationStatus(String applicationId, String newStatus, String adminId) {
        Optional<JobApplicationModel> application = jobApplicationRepository.findById(applicationId);
        if (application.isEmpty()) {
            throw new RuntimeException("Application not found");
        }

        JobApplicationModel app = application.get();
        
        // Verify admin owns the job
        Optional<JobModel> job = jobRepository.findById(app.getJobId());
        if (job.isEmpty() || !job.get().getPostedBy().equals(adminId)) {
            throw new RuntimeException("You can only update applications for your job postings");
        }

        app.setStatus(newStatus);
        return jobApplicationRepository.save(app);
    }

    public void withdrawApplication(String applicationId, String jobSeekerId) {
        Optional<JobApplicationModel> application = jobApplicationRepository.findById(applicationId);
        if (application.isEmpty()) {
            throw new RuntimeException("Application not found");
        }

        JobApplicationModel app = application.get();
        if (!app.getJobSeekerId().equals(jobSeekerId)) {
            throw new RuntimeException("You can only withdraw your own applications");
        }

        if ("HIRED".equals(app.getStatus())) {
            throw new RuntimeException("Cannot withdraw an application that has been accepted");
        }

        jobApplicationRepository.deleteById(applicationId);
    }

    public long getApplicationCountForJob(String jobId) {
        return jobApplicationRepository.countByJobId(jobId);
    }

    public long getQualifiedApplicationCountForJob(String jobId) {
        return jobApplicationRepository.countByJobIdAndPassedInitialScreeningTrue(jobId);
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\service\JobService.java ===== */
package Springboot.service;

import Springboot.model.JobModel;
import Springboot.model.UserModel;
import Springboot.repository.JobRepository;
import Springboot.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
public class JobService {

    @Autowired
    private JobRepository jobRepository;

    @Autowired
    private UserRepository userRepository;

    private static final Logger log = LoggerFactory.getLogger(JobService.class);

    public JobModel createJob(JobModel job, String adminId) {
        // Verify admin user
        Optional<UserModel> admin = userRepository.findById(adminId);
        if (admin.isEmpty() || !"ADMIN".equals(admin.get().getRole())) {
            throw new RuntimeException("Only admins can create jobs");
        }

        // Set admin details
        UserModel adminUser = admin.get();
        job.setPostedBy(adminId);
        // Determine companyName (must be non-blank per validation)
        String resolvedCompanyName = firstNonBlank(
                adminUser.getCompanyName(),
                job.getCompanyName(),
                adminUser.getUsername()
        );
        job.setCompanyName(resolvedCompanyName);
        // Optional company details (copy from admin when present; otherwise keep provided payload values)
        if (isNotBlank(adminUser.getCompanyDescription())) job.setCompanyDescription(adminUser.getCompanyDescription());
        if (isNotBlank(adminUser.getCompanyWebsite())) job.setCompanyWebsite(adminUser.getCompanyWebsite());
        if (isNotBlank(adminUser.getCompanySize())) job.setCompanySize(adminUser.getCompanySize());
        if (isNotBlank(adminUser.getIndustry())) job.setIndustry(adminUser.getIndustry());

        log.debug("Creating job title={} companyName={} postedBy={} ", job.getTitle(), job.getCompanyName(), job.getPostedBy());

        return jobRepository.save(job);
    }

    public List<JobModel> getAllActiveJobs() {
        return jobRepository.findByIsActiveTrue();
    }

    public List<JobModel> getJobsByAdmin(String adminId) {
        return jobRepository.findByPostedBy(adminId);
    }

    public Optional<JobModel> getJobById(String jobId) {
        return jobRepository.findById(jobId);
    }

    public JobModel updateJob(String jobId, JobModel updatedJob, String adminId) {
        Optional<JobModel> existingJob = jobRepository.findById(jobId);
        if (existingJob.isEmpty()) {
            throw new RuntimeException("Job not found");
        }

        JobModel job = existingJob.get();
        if (!job.getPostedBy().equals(adminId)) {
            throw new RuntimeException("You can only update your own job postings");
        }

        // Update fields
        job.setTitle(updatedJob.getTitle());
        job.setDescription(updatedJob.getDescription());
        job.setLocation(updatedJob.getLocation());
        job.setJobType(updatedJob.getJobType());
        job.setExperienceLevel(updatedJob.getExperienceLevel());
        job.setSalaryMin(updatedJob.getSalaryMin());
        job.setSalaryMax(updatedJob.getSalaryMax());
        job.setRequiredSkills(updatedJob.getRequiredSkills());
        job.setPreferredSkills(updatedJob.getPreferredSkills());
        job.setRequirements(updatedJob.getRequirements());
        job.setBenefits(updatedJob.getBenefits());
        job.setApplicationDeadline(updatedJob.getApplicationDeadline());
        job.setSkillScoreThreshold(updatedJob.getSkillScoreThreshold());
        job.setUpdatedAt(LocalDateTime.now());

        return jobRepository.save(job);
    }

    public void deleteJob(String jobId, String adminId) {
        Optional<JobModel> job = jobRepository.findById(jobId);
        if (job.isEmpty()) {
            throw new RuntimeException("Job not found");
        }

        if (!job.get().getPostedBy().equals(adminId)) {
            throw new RuntimeException("You can only delete your own job postings");
        }

        jobRepository.deleteById(jobId);
    }

    public void deactivateJob(String jobId, String adminId) {
        Optional<JobModel> existingJob = jobRepository.findById(jobId);
        if (existingJob.isEmpty()) {
            throw new RuntimeException("Job not found");
        }

        JobModel job = existingJob.get();
        if (!job.getPostedBy().equals(adminId)) {
            throw new RuntimeException("You can only deactivate your own job postings");
        }

        job.setActive(false);
        job.setUpdatedAt(LocalDateTime.now());
        jobRepository.save(job);
    }

    public List<JobModel> searchJobs(String keyword, String location, String jobType, String experienceLevel) {
        if (keyword != null && !keyword.isEmpty()) {
            return jobRepository.findByTitleContainingIgnoreCase(keyword);
        }
        
        if (location != null && !location.isEmpty()) {
            return jobRepository.findByLocationContainingIgnoreCase(location);
        }
        
        if (jobType != null && !jobType.isEmpty()) {
            return jobRepository.findByJobTypeAndIsActiveTrue(jobType);
        }
        
        if (experienceLevel != null && !experienceLevel.isEmpty()) {
            return jobRepository.findByExperienceLevelAndIsActiveTrue(experienceLevel);
        }
        
        return getAllActiveJobs();
    }

    public List<JobModel> getJobsBySkills(List<String> skills) {
        return jobRepository.findByRequiredSkillsIn(skills);
    }

    public void incrementApplicationCount(String jobId) {
        Optional<JobModel> job = jobRepository.findById(jobId);
        if (job.isPresent()) {
            JobModel jobModel = job.get();
            jobModel.setApplicationCount(jobModel.getApplicationCount() + 1);
            jobRepository.save(jobModel);
        }
    }

    private static boolean isNotBlank(String s) {
        return s != null && !s.trim().isEmpty();
    }

    private static String firstNonBlank(String... values) {
        if (values == null) return null;
        for (String v : values) {
            if (v != null && !v.trim().isEmpty()) return v.trim();
        }
        return null;
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\service\LLMAnalysisService.java ===== */
package Springboot.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;

@Service
public class LLMAnalysisService {

    @Value("${openrouter.api.key:your-api-key-here}")
    private String apiKey;

    @Value("${openrouter.api.url:https://openrouter.ai/api/v1/chat/completions}")
    private String apiUrl;

    private final WebClient webClient;

    public LLMAnalysisService() {
        this.webClient = WebClient.builder()
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(10 * 1024 * 1024)) // 10MB
                .build();
    }

    public SkillAnalysisResult analyzeResumeAgainstJob(String resumeText, String jobDescription, 
                                                      List<String> requiredSkills) {
        try {
            String prompt = buildAnalysisPrompt(resumeText, jobDescription, requiredSkills);
            
            Map<String, Object> requestBody = new HashMap<>();
            requestBody.put("model", "anthropic/claude-3.5-sonnet");
            
            List<Map<String, String>> messages = new ArrayList<>();
            Map<String, String> message = new HashMap<>();
            message.put("role", "user");
            message.put("content", prompt);
            messages.add(message);
            
            requestBody.put("messages", messages);
            requestBody.put("max_tokens", 1000);
            requestBody.put("temperature", 0.3);

            Mono<Map> response = webClient.post()
                    .uri(apiUrl)
                    .header("Authorization", "Bearer " + apiKey)
                    .header("Content-Type", "application/json")
                    .bodyValue(requestBody)
                    .retrieve()
                    .bodyToMono(Map.class);

            Map<String, Object> result = response.block();
            
            if (result != null && result.containsKey("choices")) {
                List<Map<String, Object>> choices = (List<Map<String, Object>>) result.get("choices");
                if (!choices.isEmpty()) {
                    Map<String, Object> choice = choices.get(0);
                    Map<String, String> messageContent = (Map<String, String>) choice.get("message");
                    String analysisText = messageContent.get("content");
                    
                    return parseAnalysisResult(analysisText);
                }
            }
            
            // Fallback to basic analysis if LLM fails
            return performBasicAnalysis(resumeText, requiredSkills);
            
        } catch (Exception e) {
            System.err.println("LLM Analysis failed: " + e.getMessage());
            // Fallback to basic analysis
            return performBasicAnalysis(resumeText, requiredSkills);
        }
    }

    private String buildAnalysisPrompt(String resumeText, String jobDescription, List<String> requiredSkills) {
        return String.format("""
            You are an expert HR analyst. Analyze the following resume against the job description and provide a skill match score.
            
            JOB DESCRIPTION:
            %s
            
            REQUIRED SKILLS:
            %s
            
            RESUME TEXT:
            %s
            
            Please provide your analysis in the following format:
            SCORE: [0-100]
            ANALYSIS: [Detailed analysis of skill matches, gaps, and overall fit]
            MATCHED_SKILLS: [List of skills from resume that match job requirements]
            MISSING_SKILLS: [List of required skills not found in resume]
            
            Be objective and consider:
            1. Technical skill matches
            2. Experience level alignment
            3. Domain knowledge relevance
            4. Overall candidate potential
            """, 
            jobDescription, 
            String.join(", ", requiredSkills), 
            resumeText.substring(0, Math.min(resumeText.length(), 3000)) // Limit resume text
        );
    }

    private SkillAnalysisResult parseAnalysisResult(String analysisText) {
        SkillAnalysisResult result = new SkillAnalysisResult();
        
        try {
            // Extract score
            if (analysisText.contains("SCORE:")) {
                String scoreLine = analysisText.substring(analysisText.indexOf("SCORE:") + 6);
                String scoreStr = scoreLine.split("\n")[0].trim();
                result.setScore(Integer.parseInt(scoreStr.replaceAll("[^0-9]", "")));
            }
            
            // Extract analysis
            if (analysisText.contains("ANALYSIS:")) {
                String analysisStart = analysisText.substring(analysisText.indexOf("ANALYSIS:") + 9);
                String analysis = analysisStart.split("MATCHED_SKILLS:")[0].trim();
                result.setAnalysis(analysis);
            }
            
            result.setFullAnalysis(analysisText);
            
        } catch (Exception e) {
            result.setScore(50); // Default score
            result.setAnalysis("Analysis parsing failed, using default score.");
            result.setFullAnalysis(analysisText);
        }
        
        return result;
    }

    private SkillAnalysisResult performBasicAnalysis(String resumeText, List<String> requiredSkills) {
        SkillAnalysisResult result = new SkillAnalysisResult();
        
        String lowerResumeText = resumeText.toLowerCase();
        int matchedSkills = 0;
        
        for (String skill : requiredSkills) {
            if (lowerResumeText.contains(skill.toLowerCase())) {
                matchedSkills++;
            }
        }
        
        int score = requiredSkills.isEmpty() ? 50 : (matchedSkills * 100) / requiredSkills.size();
        
        result.setScore(score);
        result.setAnalysis(String.format("Basic analysis: %d out of %d required skills found in resume.", 
                                       matchedSkills, requiredSkills.size()));
        result.setFullAnalysis("Fallback analysis used due to LLM service unavailability.");
        
        return result;
    }

    public static class SkillAnalysisResult {
        private int score;
        private String analysis;
        private String fullAnalysis;

        // Getters and setters
        public int getScore() { return score; }
        public void setScore(int score) { this.score = score; }
        
        public String getAnalysis() { return analysis; }
        public void setAnalysis(String analysis) { this.analysis = analysis; }
        
        public String getFullAnalysis() { return fullAnalysis; }
        public void setFullAnalysis(String fullAnalysis) { this.fullAnalysis = fullAnalysis; }
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\service\ResumeParsingService.java ===== */
package Springboot.service;

import org.apache.tika.Tika;
import org.apache.tika.exception.TikaException;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;

@Service
public class ResumeParsingService {

    private final Tika tika = new Tika();

    public String parseResume(MultipartFile file) throws IOException, TikaException {
        try (InputStream inputStream = file.getInputStream()) {
            return tika.parseToString(inputStream);
        }
    }

    public String parseResume(InputStream inputStream) throws IOException, TikaException {
        return tika.parseToString(inputStream);
    }

    public boolean isSupportedFileType(String contentType) {
        return contentType != null && (
            contentType.equals("application/pdf") ||
            contentType.equals("application/msword") ||
            contentType.equals("application/vnd.openxmlformats-officedocument.wordprocessingml.document") ||
            contentType.equals("text/plain")
        );
    }

    public String extractSkillsAndExperience(String resumeText) {
        // Basic skill extraction logic - can be enhanced with NLP
        StringBuilder analysis = new StringBuilder();
        
        String lowerText = resumeText.toLowerCase();
        
        // Common programming languages
        String[] programmingSkills = {"java", "python", "javascript", "react", "spring", "node.js", 
                                    "angular", "vue", "c++", "c#", ".net", "php", "ruby", "go", "kotlin"};
        
        analysis.append("Technical Skills Found: ");
        for (String skill : programmingSkills) {
            if (lowerText.contains(skill)) {
                analysis.append(skill).append(", ");
            }
        }
        
        // Experience indicators
        if (lowerText.contains("years") || lowerText.contains("experience")) {
            analysis.append("\nExperience indicators found in resume.");
        }
        
        // Education indicators
        if (lowerText.contains("bachelor") || lowerText.contains("master") || 
            lowerText.contains("degree") || lowerText.contains("university")) {
            analysis.append("\nEducation background found.");
        }
        
        return analysis.toString();
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\service\UserService.java ===== */
package Springboot.service;

import Springboot.model.UserModel;
import Springboot.repository.UserRepository;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private final UserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = new BCryptPasswordEncoder();
    }

    public UserModel signup(UserModel user) throws Exception {
        if (userRepository.existsByEmail(user.getEmail())) {
            throw new Exception("Email already exists");
        }
        // Always set role to JOBSEEKER on signup (admin role is reserved and not selectable)
        user.setRole("JOBSEEKER");
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        return userRepository.save(user);
    }

    public UserModel login(String email, String password) throws Exception {
        // Special fixed admin account
        if ("admin@gmail.com".equalsIgnoreCase(email) && "123456".equals(password)) {
            UserModel admin = userRepository.findByEmail(email).orElse(null);
            if (admin == null) {
                admin = new UserModel();
                admin.setEmail(email);
                admin.setUsername("Admin");
                admin.setRole("ADMIN");
                admin.setPassword(passwordEncoder.encode(password));
                admin = userRepository.save(admin);
            } else {
                // Ensure role is ADMIN
                if (admin.getRole() == null || !"ADMIN".equals(admin.getRole())) {
                    admin.setRole("ADMIN");
                    admin = userRepository.save(admin);
                }
            }
            return admin;
        }

        UserModel user = userRepository.findByEmail(email)
                .orElseThrow(() -> new Exception("User not found"));

        if (!passwordEncoder.matches(password, user.getPassword())) {
            throw new Exception("Invalid password");
        }

        // Non-admin users are always JOBSEEKER
        if (user.getRole() == null) user.setRole("JOBSEEKER");
        return user;
    }
}
/* ===== FILE: D:\Projects\Completed\Projects\Job_Portal\Springboot\src\main\java\Springboot\SpringbootApplication.java ===== */
package Springboot;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringbootApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringbootApplication.class, args);
	}

}
